# Архитектурное решение по трейсингу



# 1. Мотивация
Проблемы «Александрит»:
- «пропажа» заказов,
- зависания между статусами,
- долгое вычисление стоимости изготовления изделия (2–30 мин),
- потеря партнёрских заказов,
- жалобы операторов на долгую загрузку списка новых заказов в дашборде MES.

Всё это заставляет команду тратить много времени на выяснение того, где и почему «застрял» заказ.

Цели трейсинга:
- сократить MTTI (быстрая локализация: текущий статус / сервис / очередь),
- снизить жалобы о “пропаже” заказов (определяем текущий статус и последнюю успешную операцию),
- улучшить прогнозирование и оптимизацию расчёта стоимости (метрики по стадиям из span'ов),
- уменьшить откаты, rollback релизов (точная причина деградации видна в новых span'ах),
- восстановить доверие партнёров (прозрачный trace для их заказов, агрегаты SLA).



# 2. Предлагаемое решение
Файл диаграммы контейнеров: [jewerly_c4_model (original fixed, OTel)](<jewerly_c4_model (original fixed, OTel).drawio>)

Решение базового задания: страница `OTel` (новые компоненты выделены красным цветом)


## 2.1 Покрываемые системы и точки риска
- Shop API (инициализация заказа `INITIATED`, загрузка файла `FILE_UPLOADED`, переход `SUBMITTED`).
- CRM API (`MANUFACTURING_APPROVED`, `CLOSED`).
- MES API (`PRICE_CALCULATION_STARTED`/`PRICE_CALCULATED`, `MANUFACTURING_STARTED`/`MANUFACTURING_COMPLETED`, `PACKAGING`, `SHIPPED`).
- RabbitMQ (публикация и обработка событий статусов, расчёта стоимости).
- Долгая операция расчёта цены внутри MES (калькулятор).
- Запрос для дашборда MES (страница со списком заказов).


## 2.2 Риски зависаний
- Отсутствие `PRICE_CALCULATED` после `SUBMITTED` (расчёт завис, потеря сообщения).
- Отсутствие `MANUFACTURING_STARTED` после `MANUFACTURING_APPROVED` (оператор не «взял» или событие потерялось).
- Пропуски `PACKAGING`/`SHIPPED`/`CLOSED` (при отслеживании этапа доставки).
- Длинный расчёт стоимости > SLA.
- Сообщение в очереди не обработано (долгое время не выходит из `ready`, нет consumer span).
- Несогласованность статусов между сервисами.

## 2.3. Список данных в трейсинге
Каждый trace (заказ):
- trace_id, root span: order.lifecycle

Spans (примеры):
- order.root (создаётся при `INITIATED`)
- shop.init, shop.submit
- mes.price.calc (имеет polygon_count, complexity_class, calc_phase_subspans; при необходимости включает подпроцессы)
- crm.approve.manufacturing
- mes.manufacturing.start, mes.manufacturing.complete (operator_id)
- mes.packaging, mes.shipped
- crm.close

Messaging:
- mq.publish.status, mq.consume.status
- mq.publish.price, mq.consume.price

Атрибуты:
- order_id
- event_version
- prev_status, new_status
- queue, message_id, retry_count
- polygon_count, complexity_class
- operator_id (обезличивание опционально)
- partner_id (для внешних)
- status_transition_latency (derived)

Ошибки:
- error_code, error_message, stack flag

Связь:
- parent span id (асинхронно: link вместо parent для RabbitMQ).

Derived (для агрегации):
- stage_duration (per status pair)
- publish_to_consume_latency
- calc_duration
- gap_detected (bool)


## 2.4 Технологии
- OpenTelemetry SDK (Java, C#, JS) в Shop API, CRM API, MES API бэкенд.
- OpenTelemetry instrumentation для HTTP, RabbitMQ (publish/consume), DB queries (краткие spans для проблемных SELECT на dashboard).
- Вставка вручную span'ов для длинных бизнес операций (расчёт стоимости, упаковка).
- RabbitMQ: распространение trace_id и order_id в message headers при publish, извлечение при consume.

**Сбор**
- OTel Collector (приём OTLP: трейсы, метрики; обработка spanmetrics).
- Tracing Storage (Jaeger / Tempo)
- Экспорт трейсов в Jaeger / Tempo.
- Агрегация спанов в метрики (OTel Collector spanmetrics processor) и экспонирование через Prometheus exporter (/metrics) или remote write.

_Расширение (см. раздел 5.)_
- Derived metrics в Prometheus (например: latency, gap detection, stage duration, publish_to_consume_latency, error rate)
- Alertmanager для конфигурирования алертов по нарушениям SLA, обнаруженным gap'ам, повышенному уровню ошибок и задержкам
- Gap Detector Job для анализа трейсов и метрик для выявления пропусков переходов статуса заказа, интегрируется с Tracing Storage, Prometheus и Alertmanager для публикации сигналов и алертов.

**Просмотр**
- Grafana Tempo для поиска трейсов.



# 3. Компромиссы
- Полное покрытие фронтов (SPA) затратно: начальное покрытие только ключевых действий пользователя (submit, upload).
- Высокий sampling (100%) увеличит потребление ресурсов (нагрузка CPU/Memory, хранилище), поэтому стоит использовать adaptive sampling (например, 100% для долгих операций (>5s), 10% – для быстрых).
- Интеграция трейсинга в MES потребует доработки кода платформы, что увеличит стоимость и время внедрения.
- Трассировка всей db-активности приведёт к сильному зашумлению трейсов, поэтому стоит оставить только проблемные (в первую очередь запрос c дашборда MES).



# 4. Безопасность
- RBAC на просмотр трасс (роли: support, dev, ops, partner_readonly).
- Очистка PII (Personally Identifiable Information): атрибуты email, phone не логируются, только идентификаторы user_id / partner_id.
- Шифрование in-transit (TLS между SDK и Collector, Collector'ом и хранилищем).
- Retention 14/90: полные трейсы 14 дней (достаточно для решения инцидентов), агрегированные метрики 90 дней.
- Маскирование, хеширование operator_id при экспорте наружу.
- Ограничение внешнего доступа: блокирование доступа к интерфейсам трейсинга из внешней сети (только через VPN/внутренние сегменты)



# 5. Дополнительное задание: автоматический мониторинг из трейсов
Файл диаграммы контейнеров: [jewerly_c4_model (original fixed, OTel).drawio](<jewerly_c4_model (original fixed, OTel).drawio>)

Страница `OTel (доп.)` (компоненты для автоматического мониторинга выделены зелёным)


## 5.1 Новые компоненты (на диаграмме выделены зелёным цветом)
- Trace Metrics Processor внутри OTel Collector (генерация бизнес-метрик из спанов: `price_calc_duration_seconds`, длительности нахождения заказа на этапе `stage_duration` и др.).
    *  Стандартные метрики spanmetrics генерируются OTel Collector самостоятельно
- Prometheus (приём дополнительных метрик из OTel Collector).
- Gap Detector Job (поиск пропусков статусных переходов по трейсам и публикация сигналов).
- Alertmanager (правила на агрегированных метриках: p95, gap, задержки publish/consume и т.д.), уведомления
- Расширение Grafana: запросы к Prometheus и переход к трассам (через Tempo/Jaeger datasource, exemplars).


## 5.2 Новые потоки данных
- Spans → OTel Collector → Tracing Storage (сырой трейс для детализации).
- Spans → OTel Collector (Trace Metrics Processor) → spanmetrics + бизнес метрики → Prometheus (scrape).
- Prometheus → Alertmanager (оценка условий: p95 > SLA, рост gap_detected_total, повышенный publish_to_consume_latency).
- Gap Detector Job:
  - Чтение трасс (Tracing Storage) или метрик переходов (Prometheus).
  - Генерация алертов (прямо в Alertmanager) и/или инкремент метрик gap_detected_total.
- Grafana:
  - Запросы (Queries) к Prometheus (графики p95, error rate, gap и др.).
  - Datasource Jaeger/Tempo (поиск по order_id / trace_id).
  - Переход из точки метрики к конкретному trace (exemplar / trace link).


## 5.3 Новый функционал
- Автоматическое вычисление технических (latency, count и др.) и бизнес-метрик (длительность стадий, расчёт цены) прямо из трасс.
- Раннее обнаружение «застрявших» заказов (gap) и задержек между publish и consume.
- Централизованный алертинг по p95 SLA и пропускам статусных переходов.
- Быстрый переход от аномальной метрики к конкретному trace для разбора.
- Снижение ручного анализа инцидентов: система сама сигнализирует о деградации этапов жизненного цикла заказа.