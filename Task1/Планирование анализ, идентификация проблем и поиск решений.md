# 1. Список проблем (текущих и потенциальных)


## Недостаточная проработанность статусов заказа для устойчивой модели (state machine).

- В отличие от описания процесса производства изделия `MANUFACTURING_STARTED` и `MANUFACTURING_COMPLETED` (\[MES\]), у вычисления стоимости заказа (`PRICE_CALCULATED`, \[MES\]) и его упаковки `PACKAGING` (\[MES\]) нет чёткого определения процесса, т.е. в модели статусов есть смешение понятий «старт»/«окончание» и «процесс», которые в дополнение к этому неточно определены.
    - Нужно добавить длительное состояние (`PRICE_CALCULATION_STARTED`). При вычислении стоимости модели между статусами `SUBMITTED` (\[онлайн-магазин\]) и `PRICE_CALCULATED` (\[MES\]) есть непрозрачный интервал отслеживания статуса заказа между \[онлайн-магазин\] и \[MES\], равный 2-30 мин. В этот период заказ выглядит “застрявшим”.
    - Аналогично с упаковкой заказа (лучше разделить `PACKAGING` (\[MES\]) на `PACKAGING_STARTED` и `PACKAGING_COMPLETED`), оплатой (`WAITING_PAYMENT`), отгрузкой (`WAITING_SHIPMENT_CONFIRMATION`).
- Нет негативных/альтернативных статусов: `CANCELLED`, `REJECTED` (отказ системы в процессе расчёта стоимости), `ERROR` (системная ошибка), `ON_HOLD` (остановка работы с заказом), `MANUFACTURING_FAILED` / `REWORK_REQUIRED`. Это также может приводить к “потере” заказов, т.к. смена их статусов не отражает реальную ситуацию при обработке заказа и его изготовлении на производстве.
- Нет подтверждения о доставке заказа от транспортной компании `DELIVERED`. Сейчас есть только `CLOSED`, который смешивает завершение бизнес‑процесса с фактом доставки.
- Нет возврата/гарантий: `RETURN_REQUESTED` / `RETURNED`.

Рекомендуемый минимальный поток:
| Заголовок                       | Источник           | Статус    |
| ------------------------------- | ------------------ | --------- |
| `INITIATED`                     | \[онлайн-магазин\] |           |
| `FILE_UPLOADED`                 | \[онлайн-магазин\] |           |
| `SUBMITTED`                     | \[онлайн-магазин\] |           |
| `PRICE_CALCULATION_STARTED`     | \[MES\]            | Новый     |
| `PRICE_CALCULATED`              | \[MES\]            |           |
| `REJECTED`                      | \[MES\]            | Новый     |
| `CANCELLED`                     | \[CRM\]            | Новый     |
| `MANUFACTURING_APPROVED`        | \[CRM\]            |           |
| `MANUFACTURING_STARTED`         | \[MES\]            |           |
| `MANUFACTURING_FAILED`          | \[MES\]            | Новый     |
| `MANUFACTURING_COMPLETED`       | \[MES\]            |           |
| `PACKAGING`                     | \[MES\]            | Удалённый |
| `PACKAGING_STARTED`             | \[MES\]            | Новый     |
| `PACKAGING_COMPLETED`           | \[MES\]            | Новый     |
| `SHIPPED`                       | \[MES\]            |           |
| `DELIVERED`                     | \[CRM\]            | Новый     |
| `CLOSED`                        | \[CRM\]            |           |

Также нужно расширить модель статусов за счёт параллельных/исключительных ситуаций:
- `ERROR` (любая стадия) → возвращение к предыдущей или `CANCELLED` (требует ручного вмешательства).
- `ON_HOLD` (заморозка производства).
- `MANUFACTURING_FAILED` (возврат к `MANUFACTURING_STARTED`).

Что сделать:
- Описать граф допустимых переходов.
- Определить систему, отвечающую за статус на каждом шаге.
- Каждое изменение статуса публикуется как идемпотентное событие с полями:
    - `order_id`
    - монотонный номер `event_version` (игнорирование повторного получения той же версии, отслеживание пропущенных событий)
    - общий контекст процесса `correlation_id` (общий идентификатор цепочки одного бизнес-процесса (например, создание заказа, расчёт цены или производство изделия)) для отслеживания последовательности (полный журнал жизни заказа, группировка логов и метрик) и трейсинга
- Метрики времени в длинных состояниях (`price_calculation`, `manufacturing`, `packaging`).


## Текущие (явные) проблемы

1. Просроченные заказы: расхождения статусов между CRM и MES (несогласованная модель жизненного цикла).
    1. Жалобы внешних API‑пользователей: медленные ответы или «пропажа» заказа (нет сквозного трейсинга, непонятен статус обработки).
    2. Продолжительная операция расчёта стоимости (2–30 мин) может удерживать рабочий (consumer) поток, который уже взял сообщение из очереди. Пока он не обработал сообщение (не ack’нул его), оно «повисает» и новые сообщения с тем же приоритетом остаются в ожидании в очереди, формируя её хвост (backlog).
        - Т.е. при малом количестве рабочих процессов (воркеров), каждый из которых держит единственное сообщение из очереди долгий период (head‑of‑line blocking, блокирование очереди обработчиком её первого элемента), снижается пропускная способность расчёта стоимости изготовления изделия по заданной модели, что приводит к росту backlog'а, увеличению латентности для последующих заказов и создаёт ощущение «пропажи» сообщений.
        - Отсутствие _back pressure_/_rate limiting_ для внешних API привёл к всплескам нагрузки.
        - Далее всплеск заказов увеличивает глубины очереди и ведёт к риску переполнения (памяти, дискового пространства) – снижению производительности. Сначала будет блокирована публикация событий (back pressure в MQ), повышены задержки, а при определённых условиях (политики очереди: max-length, max-length-bytes, TTL с drop-head/drop-tail и др.) сообщения из очереди могут быть окончательно удалены.
        - Отсутствие кеширования и идемпотентности результатов длительных расчётов приводит к загрузке брокера и системы \[MES\] дубликатами запросов, что также приводит к увеличению хвоста.

2. Задержки загрузки первой страницы MES: тяжёлый запрос (возможно: нет индексов, сортировка по «новизне» без оптимизации), отсутствие кеша.
    1. Пагинация внедрена, но без оптимизации данных (возможен полный обход).

3. Нет стратегий ретраев (сколько раз, с какими интервалами и куда помещать сообщение перед его окончательной сдачей в DLQ), экспоненциального backoff (повторные попытки делаются либо сразу – слишком плотно, либо вообще не делаются).

4. Отсутствует хранилище (schema registry) и версионирование формата сообщений (`schema_version`, политика совместимости) — любые нескоординированные изменения сообщений повышают риск инцидентов, т.к. могут сломать потребителей.

5. Отсутствует append-only журнал переходов статусов (audit trail), в котором фиксируется переход текущего состояния (статуса) в новое состояние (предыдущие события не изменяются). Это не позволяет восстановить последовательность переходов, вычислить длительность этапов, отличить пропуск от задержки и в целом усложняет анализ инцидентов.

6. Потенциальные race conditions при назначении заказа (_кто взял заказ, тот и получит оплату_), нет блокировок/атомарного назначения исполнителя заказа, что делает возможным выполнение одновременных конкурирующих операций – двойное взятие заказа разными операторами, перезапись или спорный статус.

7. Ручные релизы в release/prod, медленный ручной цикл QA-тестирования ведёт к задержкам выхода фиксов, накоплению списка известных и незакрытых багов, росту backlog'а, также к замедлению, даже блокированию разработки в целом

8. Единственный экземпляр каждого приложения:
    - делает невозможным горизонтальное масштабирование,
    - создаёт множество “единственных точек отказа” (Single Point of Failure, SPOF),
    - невозможно выполнять обновления без простоев,
    - всплески активности (возрастание потока новых заказов, расчётов стоимости от клиентов и партнёров) ведут к забиванию очередей и росту времени ответа

9. Единственный экземпляр каждой базы данных:
    - смешанное выполнение операций работы с заказами (Online Transaction Processing, OLTP) и тяжёлых операций чтения (дашборд \[MES\] системы) в одном экземпляре базы данных приводит к блокировкам, росту latency.
        - В качестве решения нужно рассмотреть репликацию базы данных, разделения её на master (write) и replica (read).
    - Отсутствие резервирования/репликации делает трудозатратным, или даже невозможным восстановление после сбоя дольше (рост RTO и RPO).
    - Отсутствие изоляции: долгие операции (например, расчёт цены) конкурируют за ресурсы с другими операциями, подавляя выполнение быстрых запросов (изменение статусов, получение списка новых заказов).

10. Отсутствие мониторинга (кроме Яндекс.Метрики фронта) → слепота по очередям, RPS, latency, DLQ.
    1. Нет централизованных логов → разбор инцидентов «со слов клиентов».
    2. Нет метрик по глубине очереди / Dead Letter Queue (DLQ) / времени прохождения заказа.
    3. Отсутствие трейсинга → невозможность понять где «завис» статус.


## Потенциальные проблемы

- Рост использования API‑партнёров сопряжён с необходимостью квотирования, версионирования и изоляции.
- Усложнение поддержки без разграничения доступа к ресурсам системы и её мониторингу на основе RBAC.
- Отсутствие использования Backpressure повышает нагрузку на внутренние ресурсы.
- Риск каскадных отказов без Circuit breaker.
- Усложнение эксплуатации без использования автоматического масштабирования, в котором компания остро нуждается уже в настоящий момент.



# 2. Список инициатив (эпики / задачи)


## 2.1 Наблюдаемость

- Внедрение мониторинг (Prometheus + Grafana): очереди, RPS, latency, ошибки, время расчёта цены.
- Настройка алертов (глубина очереди, DLQ > 0, SLA времени расчёта, рост 500).
- Внедрение распределённого трейсинг (OpenTelemetry + Zipkin/Jaeger) с correlation/order id.
- Внедрение централизованного логирования (OpenSearch / Loki), парсинга структурированных JSON логов.
- Отслеживание метрики сквозного времени заказа.


## 2.2 Надёжность очередей / интеграций

- Добавление DLQ, политики обработки, автоматические ретраи с backoff.
- Реализация идемпотентности через ключи.
- Внедрение версионирования схем сообщений.
- Использование correlation id и порядкового номера события (version) для синхронизации статусов.
- Разделение топиков/роутингов: расчёт цены, статус производства, административные события.
- Использование Backpressure: ограничение параллельных расчётов, rate limit внешних API.


## 2.3 Производительность

- Подключение кеширования для списка новых заказов (Redis), результатов расчёта цен.
- Внедрение индексов и материализованных представлений, денормализация для дашборда MES.
- Оптимизация дашборда
    - добавление композитных/частичных покрывающих индексов (status + created_at),
    - использование отдельной денормализованной таблицы/кеша, обновляемых сразу по событию статуса (≈<1 c лаг),
    - денормализация часто вычисляемых полей (current_stage_duration, is_active, sort_key) в read-модель для минимизации full scan и конкуренции с транзакционными обновлениями.
    - при необходимости аналитики (допустим лаг) – создание материализованных представлений (снижает нагрузку на основные таблицы; `active_orders`, `latest_orders`) с периодическим `REFRESH CONCURRENTLY` (без блокировки чтения) каждый N минут
- Выделение read-replica для аналитических/листинговых запросов.
- Асинхронная постановка расчёта + статус «CALCULATION_IN_PROGRESS».
- Оптимизация загрузки больших 3D файлов (chunked, предварительная валидация).


## 2.4 Архитектурное масштабирование

- Автоматическое горизонтальное масштабирование API (эластичность и устранение SPOF).
- Проверки health checks, probes
    * Liveness probe: обнаруживает «зависший» процесс (deadlock, утечка) → перезапуск.
    * Readiness probe: сообщает балансировщику, что экземпляр готов принимать трафик (инициализация завершена) и наоборот — исключает узел из ротации перед остановкой.
    * Probes – точное управление трафиком и самовосстановление.
- Graceful shutdown – релизы, масштабирование вниз, ручная остановка, вывод из ротации при деградации производительности инстанса без потерь и дубликатов.
- Circuit breaker / timeout / retry политики между сервисами.


## 2.5 Процесс / качество

- Автоматизация тестов (smoke, контрактные, интеграционные через Testcontainers).
- CI/CD: автоматический деплой release (при прохождении тестов) с постепенной раскаткой (progressive rollout) / blue-green подход с двумя параллельными окружениями.
- Внедрение feature flags для инкрементальных изменений.
- Определение SLA/SLO для ключевых операций (расчёт цены, получение списка заказов).


## 2.6 Данные / модель

- Ведение append-only журнала переходов статусов.
- Нормализация модели статусов и явные переходы (state machine).
    - Формализация с виде графа, валидация
- Распределённая уникальная блокировка заказа в момент взятия в работу.


## 2.7 Безопасность / доступы

- Ролевой доступ к Kubernetes и наблюдаемости (RBAC): разграничить чтение/изменение метрик, логов, алертов (viewer/dev/ops/admin) во избежание утечек и случайных правок.
- Маскирование чувствительных атрибутов в логах (PII) в логах: исключать или обрезать email, телефон, адрес; использовать идентификаторы (order_id) вместо исчерпывающих данных; централизованный логгер с правилами маскировки.


## 2.8 Управление API

- Версионирование внешнего API.
- Rate limiting для партнёров, отчёты по использовании.



# 3. Приоритизация

1. Наблюдаемость: мониторинг + логирование + трейсинг (иначе «слепой ремонт»).
2. Надёжность очередей: DLQ, идемпотентность, correlation id, ретраи.
3. Производительность MES (кеширование, добавление индексов, репликация с read replica) для снижения жалоб операторов.
4. Автоматизация CI/CD и тестов (ускорение релизов, снижение накопления багов).
    * Может реализовываться параллельно с кешированием MES
5. Кеширование результатов расчёта цены (снижение времени ответа для повторных запросов).
6. Backpressure и rate limiting внешних API.
7. Масштабирование инстансов (горизонтально, автоматически).
8. Аудит статусов / упорядочивание модели (state machine).
9. Circuit breakers / timeout policy.
10. Версионирование API, квотирование партнёрских обращений, отчёты.

Приоритетность определяется необходимостью сначала увидеть состояние системы (наблюдаемость и количественная оценка будущих оптимизаций), затем не допустить потери данных (надёжность очередей), решить проблемы доступности данных для пользователей (дашборды MES), после чего сфокусироваться на обеспечении устойчивости потока изменений (CI/CD).



# 4. Целевая архитектура через 6 месяцев

- Все API работают как минимум в 3–4 инстансах за балансировщиком с autoscaling по CPU/latency.
- Используются Prometheus, Grafana и реализован алертинг (ключевые метрики: глубина очереди, время расчёта стоимости, время выполнения заказа order lead time).
    * Метрик времени работы с заказом может несколько (_тем более, сейчас компания испытывает сложности с выполнением заказов, мониторингом их статусов_) – каждая из них может определяться как промежуток времени, прошедший с получения заказом одного выбранного статуса до его перехода в другой статус. Например:
        - Время ожидания клиентом (_Customer lead time_): `INITIATED` (`SUBMITTED`) → `DELIVERED`. Отражает «сколько ждёт клиент».
        - Время выполнения заказа (_Internal lead time_): `SUBMITTED` → `CLOSED` (игнорирование времени доставки клиенту).
        - Время производства (_Manufacturing lead time_): `MANUFACTURING_STARTED` → `MANUFACTURING_COMPLETED`.
        - Время вычисления стоимости (_Pricing lead time_): `PRICE_CALCULATION_STARTED` → `PRICE_CALCULATED`.
        - Время доставки (_Fulfillment (post‑production)_): `PACKAGING_STARTED` → `DELIVERED`.
- OpenTelemetry (внедрены trace/span id, orderId correlation).
- Централизованные структурированные логи (OpenSearch/Loki).
- Redis: кеширование N последних заказов, а также результатов расчёта цены (TTL).
- RabbitMQ с DLQ, раздельными обменниками (exchange) по типам событий; метрики DLQ.
- Использование read replica для MES DB / возможно вынос отчётных запросов.
- Стейт-машина статусов: валидация переходов, события в виде append log.
- Rate limiting внешних API, backpressure расчётов (защита пула воркеров).
- Автоматический деплой в release + progressive deploy в prod-окружении, покрытие тестами критических процессов приложения.
- Алерты по SLO: 95% расчётов < X мин, 99% выдача списка заказов < Y мс.
- Circuit breaker для защиты при деградации.


# 5. Топ-3 инициатив при ограниченных ресурсах

1. Наблюдаемость (мониторинг + трейсинг + логирование).
   - Без неё невозможно достоверно подтвердить «потерю» сообщений или локализовать узкое место, поэтому она имеет максимальное влияние на скорость решения инцидентов и доверие бизнесу клиентов и партнёров.

2. Надёжность и структурирование очередей (DLQ, идемпотентность, correlation id, ретраи).
   - Снижает «пропажу» заказов, устраняет основной источник жалоб и потери контрактов.

3. Производительность списка заказов MES (индексы, кеширование, репликация с read replica).
   - Снижает жалобы операторов, ускоряет их работу, повышает операционную эффективность.
